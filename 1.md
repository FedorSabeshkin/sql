# Первое задание

## Формат
а) SQL
б) Оформление предшесствующего решения на русском языке

1. 
```SQL
SELECT df.*, squad.*
FROM dwarfs df
INNER JOIN squad squad ON df.squad_id = squad.squad_id;
```

Достать гн.*, отряд.*
Из гном гн, отряд отряд
Соеденить пересечение по гн.squad_id = отряд.squad_id


2. 
```SQL
SELECT df.*
FROM dwarfs df
WHERE df.profession = "miner"
		AND df.squad_id = null;
```


3. 
```SQL
SELECT tasks.*
FROM (
	SELECT tasks_max.*
	FROM tasks tasks_max
	WHERE tasks_max.priority = (
								SELECT MAX(ts.priority)
								FROM tasks ts)
	) tasks
WHERE tasks.status = "pending";
```

Достать задачи.*
Из (
Достать задачи_max.*
Из задачи задачи_max
Где задачи_max.priority = (Доставь MAX(зд.priority)
Из Задачачи зд)
) задачи
где задачи.status = "pending"

4. 

```SQL
SELECT df.dwarf_id, COUNT(*) AS item_amount
FROM dwarfs df
INNER JOIN items items df.dwarf_id = items.owner_id
GROUP BY df.dwarf_id;
```

Достать гн.dwarf_id, COUNT(*) AS item_amount
Из гном гн
Объеденить Пересечение Предметы предметы гн.dwarf_id = предметы.owner_id
group_by гн.dwarf_id

5. 

```SQL
SELECT squads.squad_id, COUNT(*) AS dwarf_amount
FROM squads squads
LEFT JOIN dwarfs df squads.squad_id = dw.squad_id
GROUP BY df.dwarf_id;
```

Задача почти изоморфна прошлой.

Достать отряд.squads_id, COUNT(*) AS dwarf_amount
Из отряд отряд
Объеденить Слева Гном гн отряд.squad_id = гн.squad_id
group_by гн.dwarf_id


6. 

```SQL
SELECT df_items_amount_second.profession
FROM (
		SELECT df.dwarf_id, df.profession, COUNT(*) as task_amount
		FROM dwarfs df
		INNER JOIN tasks tasks df.dwarf_id = tasks.assigned_to 
		WHERE tasks.status = "pending" OR tasks.status = "in_progress" 
		GROUP BY df.dwarf_id
	) AS df_items_amount_second
INNER JOIN (
	SELECT MAX(df_items_amount_first.task_amount) max_working_task_per_dwarf
	FROM (
			SELECT df.dwarf_id, df.profession, COUNT(*) as task_amount
			FROM dwarfs df
			INNER JOIN tasks tasks df.dwarf_id = tasks.assigned_to 
			WHERE tasks.status = "pending" OR tasks.status = "in_progress" 
			GROUP BY df.dwarf_id
		) AS df_items_amount_first
	) AS max_tasks_amount
max_tasks_amount.max_working_task_per_dwarf = df_items_amount_second.task_amount;
```

Найти число задач у каждого гнома

(
Достать гн.dwarf_id, COUNT(*) AS task_amount
Из гном гн
Объеденить Пересечение Задача задача гн.dwarf_id = задача.assigned_to 
group_by гн.dwarf_id ) AS гн_число_задач


Найти число незавершенных задач у каждого гнома

(
Достать гн.dwarf_id, гн.profession, COUNT(*) AS task_amount
Из гном гн
Объеденить Пересечение Задача задача гн.dwarf_id = задача.assigned_to 
Где Задача.status = "pending" OR Задача.status = "in_progress"
group_by гн.dwarf_id ) AS гн_число_задач


Найти максимальное число незавершенных задач

(
SELECT MAX(гн_число_задач.task_amount) max_working_task_per_dwarf
ИЗ гн_число_задач 
) AS макс_число_задач


Найти гномов с максимальным числом задач

(
Достать гн_число_задач.profession
Из (гн_число_задач) гн_число_задач
inner join макс_число_задач макс_число_задач.max_working_task_per_dwarf = гн_число_задач.task_amount
)

==Собранное выражение==
Достать гн_число_задач_2.profession
Из (
	Достать гн.dwarf_id, гн.profession, COUNT(*) AS task_amount
	Из гном гн
	Объеденить Пересечение Задача задача гн.dwarf_id = задача.assigned_to 
	Где Задача.status = "pending" OR Задача.status = "in_progress"
	group_by гн.dwarf_id ) 
AS гн_число_задач_2
inner join (
	SELECT MAX(гн_число_задач_1.task_amount) max_working_task_per_dwarf
		ИЗ (
			Достать гн.dwarf_id, гн.profession, COUNT(*) AS task_amount
			Из гном гн
			Объеденить Пересечение Задача задача гн.dwarf_id = задача.assigned_to 
			Где Задача.status = "pending" OR Задача.status = "in_progress"
			group_by гн.dwarf_id 
		) AS гн_число_задач_1
	) AS макс_число_задач 
макс_число_задач.max_working_task_per_dwarf = гн_число_задач_2.task_amount
====

Возможно как-то не выполнять 2 одинаковых подзапроса, но надо подумать, как это выразить в SQL.


7.
```SQL
SELECT items.type, AVG(df.age)
FROM dwarfs df
INNER JOIN items ON df.dwarf_id = items.owner_id
GROUP BY items.type;
```

Нужно построить join пересечения предметов и гномов по owner_id и dwarf_id
Сгруппировать выборку по item_type
Применить агрегирующую функцию AVG к полю dwarf_age и группировку в одном запросе

Достать item.item_type, AVG(гн.age)
Из гном гн
inner join item гн.id = item.owner_id
Сгруппировать по item.item_type

8.
```SQL
SELECT dw_without_item.*
FROM (
	SELECT dw.*, items.item_id 
	FROM dwarfs dw
	LEFT JOIN items ON df.dwarf_id = items.owner_id
	WHERE items.owner_id=NULL) AS dw_without_item
WHERE dw_without_item.age > (
	SELECT AVG(df_age.age) 
	FROM dwarfs df_age
);
```

Что бы найти гномов без предметов, мне достаточно построить join гномов и предметов left, то есть допускающий null в качестве значения предмета 
и из этого join уже доставать данные с условием, что item_id = null и всем прочим

Сделать подзапрос который вернут 1 строку - средний возраст гнома в БД

Достать *
из (
	Достать гн.*, предметы.id
	from гномы гн
	left join предметы предметы гн.id = предметы.owner_id
	ГДЕ предметы.owner_id=null) гн_без_предметов
Где age > (
 Достать AVG(age)
 из гномов
) 

