# Рефлексия по 6 заданию

1. Узнал о функции CORR, которая показывает наличие корреляции между двумя double значениями.
Если одно из значений NULL - вычисление не выполняется.

2. Используются более сложные выражения при формировании временных таблиц, которых используется меньше.
У меня: 8
В примере: 4

3. Как вычисляется период? 
Я решил, что вычисляю за 2026 год с 365 днями, на которые буду делить.  
В примере вычисляется разница между максимальной датой производства товара и минимальной датой назначения рабочего на фабрику.  
 
Причем эти данные в примере берутся из 2 разных таблиц.   
Одна из таблицы продуктов, а другая из таблицы рабочих фабрики.  

4. Для вычисления общего числа дней в которых выполнялась работа - `COUNT(DISTINCT table_name.date_field) as production_date`
Вижу что внутри `COUNT` можно передавать выражение с DISTINCT, без указания полного FROM.  
Это работает в данном кейсе при условии, что нет товаров, производство которых займет более 1 дня. 
Либо есть в production_date указываютс все дни, в рамках которых велась работа над данным продуктом.

5. `total_production_value` вычисляется как Сумма произведений от перемножения чисел из 2 таблиц: value из таблицы товаров и кол-во товара из таблицы товаров_фабрики.  
Это агрегатная функция суммы срабатывает т.к. группировку выполняем по фабрик_id, w.name, w.type и JOIN таблицы товаров и товары_фабрики.

6. Важно, что число продуктов и фабрик вычисляется через `COUNT(DISTINCT dward_id)`.   
В моем решении не учел DISTINCT.  

7. Для вычисления `avg_quality` можно было воспользоваться готовой функцией AVG, а не сначала делать вычисление общего и частного и потом делить их с защитой на NULLIF.
Это более краткое и понятное значение с AVG, кроме того, можно использовать `INTEGER`.

8. В 3/4 CTE группировка выполняется по workshop_id и еще какому-то полю. 
Я использовал только workshop_id и в 1/8 добавил production_date, для вычисления за конкретную дату.

9. Если знать контекст БД, то надо было добавить фильтрацию по категории навыка дварфа, конкретно в производстве.  
Это упростило бы вычисление изменения уровня навыка.  
`s.category = 'Crafting'`

Интиутивно такое упрощение, через знание задачи попробовал через вычисление среднего между датами, приняв, что БД только по 2026 году с 365 днями в нем, не завязываясь на значения полей дат.
Аналогично задачи о вычислении хипстеров в городах, которая решается проще, если знаем, что хипстеры есть только в Москве и Санкт Петербурге.

10. В `ORDER BY` выполняется деление...

Читабельнее было бы сделать это деление внутри SELECT и дать ему alias `AS sort_coef`, а для сортировки уже указать `ORDER BY sort_coef DESC`.

11. `GROUP BY` выполняется по очень большому числу столбцов. 
Надо ли это? Да, надо, что бы корректно работали агрегатные функции.  

Остались поля, которые не используются

12. В CTE есть поля, которые не используются в результирующем запросе, что не снижает эффективность, т.к. достаем через SELECT данные, вроде unique_inputs/unique_outputs, которые фактически не нужны.

13. `total_quantity_produced`,  
`workshop_utilization_percent` вычисляю верно при учете моего допущения что данные только по 26 году с 365 днями.

14. `material_conversion_ratio` - которое не понял как вычислить, надо вычислять как отношение из `workshop_materials` материалов и `is_input=false` к `is_input=true`.  
Верно ли что материалы тоже производятся на фабриках?

15. Для вычисления средних `average_craftsdwarf_skill` берется среднее от среднего. 
Я просто делил все навыки на всех работников. Без учета назначения работников на фабрику.



